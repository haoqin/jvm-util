package com.liyutech.quill

import com.liyutech.common.meta.TypeUtil
//
//import com.liyutech.quill.model.OrcaUser
//
//import java.time.LocalDateTime
//
import com.liyutech.quill.QuillBaseSpec
import com.liyutech.quill.QuillGenericDao
import com.liyutech.quill.model.OrcaUser
import java.time.LocalDateTime
import com.liyutech.common.meta.DataGen
import com.liyutech.common.USZipCodeInfo
import org.scalatest.*

class QuillGenericDaoSpec extends QuillBaseSpec with TestDataGen with BeforeAndAfterEach {
  val quillDao = QuillBaseSpec.h2Dao
  import quillDao.*
  import io.getquill.*
  import QuillGenericDao.*
  import DataGen.{given, *}
  import TypeUtil.*
  private inline val usCitizenship = "US"
  private inline def filter: OrcaUser => Boolean = _.citizenship == usCitizenship

  override def beforeEach() = {
    val n = quillDao.deleteAll[OrcaUser]
    insertUsers(modelsPerIteration)
  }

  private def insertUsers(n: Int): Seq[OrcaUser] = {
    val users: Seq[OrcaUser] = (0 until modelsPerIteration).map(_ => generateRandom[OrcaUser]).map(toReadableUser)
    quillDao.insertAll[OrcaUser](users)
    users
  }

  "QuillGenericDao find[T]" should "find records satisfying the given filter" in {
    val users = quillDao.find[OrcaUser](filter)
    assert(users.map(_.citizenship).forall(_ == usCitizenship))
  }
  "QuillGenericDao findBy[T]" should "find records whose ids match the given id" in {
    val users = quillDao.findBy[OrcaUser, String](usCitizenship, _.citizenship)
    assert(users.map(_.citizenship).forall(_ == usCitizenship))
  }

  "QuillGenericDao findAll[T]" should "find all records from a table" in {
    val allUsers = quillDao.findAll[OrcaUser]
    assert(allUsers.size == modelsPerIteration)
  }

  "QuillGenericDao findGroupMax[T, G, M]" should "groups records by the given groupBy function and find the maximal value for each group" in {
    val maxRecords: Seq[OrcaUser] = quillDao.findGroupMax[OrcaUser, String, LocalDateTime](_.id, _.updatedAt)
    val groupByData: Map[String, LocalDateTime] = quillDao.findAll[OrcaUser].groupBy(_.id).map { case (groupId, models) => 
        val max: LocalDateTime = models.map(_.updatedAt).max
        (groupId, max)
      }

    val result: Boolean = maxRecords.forall { expectedMaxRecord =>
      val id = expectedMaxRecord.id
      groupByData.get(id).fold(false)(_.isEqual(expectedMaxRecord.updatedAt))
    }
    assert(result)
  } 

  "QuillGenericDao.insertAll() and find()" should "insert and then verify expected number of rows in a table" in {
    val initCount = quillDao.findAll[OrcaUser].size
    println(s"initCount: $initCount")
    val insertedRows: Seq[OrcaUser] = insertUsers(modelsPerIteration)
    println(s"""insertedRows: ${insertedRows.size}""")
    val endCount = quillDao.findAll[OrcaUser].size
    println(s"endCount: $endCount")

    // val modelsMatched: Boolean = insertedRows.forall { model =>
    //   val matchedModels = quillDao.find[OrcaUser](u => u.uid == lift(model.uid))
    //   matchedModels.foreach(println)
    //   matchedModels.nonEmpty
    // }
    assert(endCount - initCount == modelsPerIteration && insertedRows.size == modelsPerIteration)
 }
//
//  //  "QuillGenericDao.autogeneratedKeyAfterInsert()" should "return auto-incremental keys after insertion to a table" in forAll(autoIncrementModels(modelsPerIteration)) { models =>
//  //    val initCount = quillDao.findAll[Pod].size
//  //
//  //    println(s"initCount: $initCount")
//  //    val primaryKeys: Seq[String] = models.map { model =>
//  //      quillDao.autogeneratedKeyAfterInsert[Pod, String](model, _.podUsername)
//  //    }
//  //
//  //    println("Primary keys:")
//  //    println(primaryKeys.mkString(","))
//  //    val endCount = quillDao.findAll[Pod].size
//  //    println(s"endCount: $endCount")
//  //    assert(endCount - initCount == modelsPerIteration && primaryKeys.size == modelsPerIteration)
//  //  }
//  //
//  //  "QuillGenericDao.insertAll()" should "insert all rows within a transactional context" in forAll(userModels(modelsPerIteration)) { models =>
//  //    val initCount = quillDao.findAll[User].size
//  //    val primaryKeys: Seq[Long] = quillDao.insertAll[User](models)
//  //    println(s"initCount: $initCount")
//  //    println("Primary keys:")
//  //    println(primaryKeys.mkString(","))
//  //    val endCount = quillDao.findAll[User].size
//  //    println(s"endCount: $endCount")
//  //    assert(endCount - initCount == modelsPerIteration && primaryKeys.sum == modelsPerIteration)
//  //  }
//  //
//  "QuillGenericDao.findMaxFields()" should "find all rows grouped by a given field that has the maximal value for a given field" in {
//    import quillDao._
//
//    val expectedMaxValues: Seq[(String, LocalDateTime)] = quillDao.findMaxFields[OrcaUser, String, LocalDateTime](_.username, _.updatedAt)
//    println(expectedMaxValues)
//    assert {
//      expectedMaxValues.forall { case (username, expectedMaxValue) =>
//        val actualMaxValue = quillDao.find[OrcaUser](_.username == lift(username)).map(_.updatedAt).max
//        println(s"username: $username, expectedMaxValue: $expectedMaxValue, actualMaxValue: $actualMaxValue")
//        expectedMaxValue == actualMaxValue
//      }
//    }
//  }
//
//  "QuillGenericDao.findGroupMax()" should "find all rows grouped by a given field that has the maximal value for a given field" in {
//    // Make sure we have updates:
//    val allUsers: Seq[OrcaUser] = quillDao.findAll[OrcaUser]
//    val updatedUsers: Seq[OrcaUser] = allUsers.map { user => user.copy(updatedAt = user.updatedAt.plusDays(1L)) }
//    quillDao.insertAll(updatedUsers)
//
//    val expectedMaxValues: Map[String, LocalDateTime] = quillDao.findMaxFields[OrcaUser, String, LocalDateTime](_.username, _.updatedAt).toMap
//    val maxRecords: Seq[OrcaUser] = quillDao.findGroupMax[OrcaUser, String, LocalDateTime](_.username, _.updatedAt) { (user, id, updatedAt) =>
//      user.updatedAt == updatedAt && user.username == id
//    }
//
//    assert {
//      maxRecords.forall { user =>
//        println(s"user.username:${user.username}, user.updatedAt: ${user.updatedAt}, expected: ${expectedMaxValues.get(user.username)}")
//        expectedMaxValues.get(user.username).fold(false)(_ == user.updatedAt)
//      }
//    }
//  }
//
//  "QuillGenericDao.findMax()" should "find all rows grouped by a given field that has the maximal value for a given field" in {
//    val expectedMaxValues: Map[String, LocalDateTime] = quillDao.findMaxFields[OrcaUser, String, LocalDateTime](_.username, _.updatedAt).toMap
//    assert {
//      expectedMaxValues.forall { case (username, expectedMaxValue) =>
//        val maxRecord: Option[OrcaUser] = quillDao.findMax[OrcaUser, String, LocalDateTime](username, _.username, _.updatedAt)
//        maxRecord.map(_.updatedAt == expectedMaxValue).fold(false)(identity)
//      }
//    }
//  }
}